import { addComponent, addImportsSources, useNuxt, defineNuxtModule, addPluginTemplate } from '@nuxt/kit';
import AllComponents from 'element-plus/es/component';
import * as AllIcons from '@element-plus/icons-vue';
import { createUnplugin } from 'unplugin';
import MagicString from 'magic-string';

const libraryName = "element-plus";
const iconLibraryName = "@element-plus/icons-vue";
const allComponents = AllComponents.map((item) => item.name);
const allIcons = Object.keys(AllIcons);
const allImportsWithStyle = [
  "ElLoading",
  "ElMessage",
  "ElMessageBox",
  "ElNotification"
];
const allImports = allImportsWithStyle;
const allNoStylesComponents = [
  "ElAutoResizer",
  "ElTooltipV2"
];
const allDirectives = {
  Loading: ["ElLoadingDirective", "ElLoading"],
  Popover: ["ElPopoverDirective", "ElPopover"],
  InfiniteScroll: "ElInfiniteScroll"
};
const allSubComponents = {
  ElBreadcrumb: ["ElBreadcrumbItem"],
  ElButton: ["ElButtonGroup"],
  ElCarousel: ["ElCarouselItem"],
  ElCheckbox: ["ElCheckboxButton", "ElCheckboxGroup"],
  ElCollapse: ["ElCollapseItem"],
  ElContainer: ["ElAside", "ElFooter", "ElHeader", "ElMain"],
  ElDescriptions: ["ElDescriptionsItem"],
  ElDropdown: ["ElDropdownItem", "ElDropdownMenu"],
  ElForm: ["ElFormItem"],
  ElMenu: ["ElMenuItem", "ElMenuItemGroup", "ElSubMenu"],
  ElRadio: ["ElRadioGroup", "ElRadioButton"],
  ElSkeleton: ["ElSkeletonItem"],
  ElSelect: ["ElOption", "ElOptionGroup"],
  ElSteps: ["ElStep"],
  ElTable: ["ElTableColumn"],
  ElTableV2: ["ElAutoResizer"],
  ElTabs: ["ElTabPane"],
  ElTimeline: ["ElTimelineItem"]
};
const defaultInjectionID = {
  prefix: 1024,
  current: 0
};
const defaultInclude = [
  /\.vue$/,
  /\.vue\?vue/,
  /\.vue\?v=/,
  /\.((c|m)?j|t)sx?$/
];
const defaultExclude = [
  /[\\/]node_modules[\\/]/,
  /[\\/]\.git[\\/]/,
  /[\\/]\.nuxt[\\/]/
];
const defaults = {
  components: allComponents,
  subComponents: allSubComponents,
  directives: allDirectives,
  imports: allImports,
  importStyle: "css",
  themes: [],
  noStylesComponents: allNoStylesComponents,
  injectionID: defaultInjectionID,
  include: defaultInclude,
  exclude: defaultExclude,
  namespace: "el",
  appendTo: [],
  icon: "ElIcon"
};

function isArray(value) {
  return Array.isArray(value);
}
function toArray(value) {
  return isArray(value) ? value : [value];
}
function toRegExp(arr, flags) {
  return new RegExp(`\\b(${arr.join("|")})\\b`, flags);
}
function genLibraryImport(list) {
  const values = list.map((item) => {
    if (isArray(item)) {
      const [name, as] = item;
      return `${name} as ${as}`;
    }
    return item;
  });
  return `import {${values.join(",")}} from '${libraryName}';`;
}
function genSideEffectsImport(value) {
  return `import '${value}';`;
}
function genIconPresets(prefix) {
  return allIcons.map((name) => {
    return [name, `${prefix}${name}`, iconLibraryName];
  });
}
function camelize(value) {
  return value.replace(/(^|-)(\w)/g, (a, b, c) => c.toUpperCase());
}
function hyphenate(value) {
  return value.replace(/\B([A-Z])/g, "-$1").toLowerCase();
}

function resolveComponents(config) {
  const { components, subComponents, icon } = config;
  const icons = icon !== false ? genIconPresets(icon) : [];
  const allComponents = /* @__PURE__ */ new Set([...components, ...icons]);
  const subComponentsMap = Object.fromEntries(
    Object.entries(subComponents).reduce((all, [key, values]) => {
      values.forEach((item) => {
        all.push([item, key]);
      });
      return all;
    }, [])
  );
  allComponents.forEach((item) => {
    const [name, alias, from] = toArray(item);
    const componentName = subComponentsMap[name] || name;
    const dir = hyphenate(componentName.slice(2));
    const filePath = from !== iconLibraryName ? `${libraryName}/es/components/${dir}/index` : from;
    addComponent({
      export: name,
      name: alias || name,
      filePath
    });
  });
}

function resolveDirectives(config, name) {
  const { directives } = config;
  if (directives[name]) {
    const [directive, styleName] = toArray(directives[name]);
    const style = styleName && getStyleDir(config, styleName);
    return [directive, style];
  }
}

function resolveImports(config) {
  const { imports, icon } = config;
  const icons = icon !== false ? genIconPresets(icon) : [];
  const allImports = /* @__PURE__ */ new Set([...imports, ...icons]);
  addImportsSources({
    from: libraryName,
    imports: [...allImports]
  });
}

function resolveInjection(config) {
  const { injectionID } = config;
  return {
    filename: `${libraryName}-injection.plugin.mjs`,
    getContents: () => {
      return `import { defineNuxtPlugin } from '#app';
import { ID_INJECTION_KEY } from 'element-plus';

export default defineNuxtPlugin(nuxtApp => {
  nuxtApp.vueApp.provide(ID_INJECTION_KEY, ${JSON.stringify(injectionID)});
})
`;
    }
  };
}

function resolveOptions() {
  const nuxt = useNuxt();
  nuxt.options.build.transpile.push(libraryName);
}

function getStyleDir(config, name) {
  if (config.importStyle === false) {
    return void 0;
  }
  const dir = hyphenate(name.slice(2));
  const type = config.importStyle === "scss" ? "index" : "css";
  return `${libraryName}/es/components/${dir}/style/${type}`;
}
function resolveStyles(config, name) {
  const { components, noStylesComponents } = config;
  const allComponents = [...components, ...allImportsWithStyle];
  if (!allComponents.includes(name) || noStylesComponents.includes(name)) {
    return void 0;
  }
  return /^El[A-Z]/.test(name) ? getStyleDir(config, name) : void 0;
}

function resolveTeleports(config) {
  const { namespace, appendTo } = config;
  const defaultId = `#${namespace}-popper-container-`;
  return {
    filename: `${libraryName}-teleports.plugin.mjs`,
    getContents: () => {
      return `import { defineNuxtPlugin } from '#app'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('app:rendered', (ctx) => {
    if (ctx.ssrContext?.teleports) {
      ctx.ssrContext.teleports = renderTeleports(ctx.ssrContext.teleports)
    }
  })
})

function renderTeleports (teleports) {
  const body = Object.entries(teleports).reduce((all, [key, value]) => {
    if (key.startsWith('${defaultId}') || ${JSON.stringify(appendTo)}.includes(key)) {
      return \`\${all}<div id="\${key.slice(1)}">\${value}</div>\`
    }
    return all
  }, teleports.body || '')
  return { ...teleports, body }
}
`;
    }
  };
}

function resolveThemes(config) {
  const nuxt = useNuxt();
  const { themes, importStyle } = config;
  const allThemes = new Set(themes);
  allThemes.forEach((item) => {
    nuxt.options.css.push(`${libraryName}/theme-chalk${importStyle === "scss" ? "/src" : ""}/${item}/css-vars.${importStyle}`);
  });
}

const componentsRegExp = /(?<=[ (])_?resolveComponent\(\s*["'](lazy-|Lazy)?([^'"]*?)["'][\s,]*[^)]*\)/g;
const directivesRegExp = /(?<=[ (])_?resolveDirective\(\s*["']([^'"]*?)["'][\s,]*[^)]*\)/g;
const importsRegExp = toRegExp(allImportsWithStyle, "g");
const transformPlugin = createUnplugin((options) => {
  const { include, exclude, transformStyles, transformDirectives } = options;
  return {
    name: `${libraryName}:transform`,
    enforce: "post",
    transformInclude(id) {
      if (exclude.some((pattern) => id.match(pattern))) {
        return false;
      }
      if (include.some((pattern) => id.match(pattern))) {
        return true;
      }
    },
    transform(code, id) {
      const imports = /* @__PURE__ */ new Set();
      const directives = [];
      const s = new MagicString(code);
      let no = 0;
      const addStyles = (styles) => {
        styles && imports.add(genSideEffectsImport(styles));
      };
      s.replace(componentsRegExp, (full, lazy, name) => {
        addStyles(transformStyles(camelize(name)));
        return full;
      });
      s.replace(importsRegExp, (full, name) => {
        addStyles(transformStyles(camelize(name)));
        return full;
      });
      s.replace(directivesRegExp, (full, name) => {
        const directiveConfig = transformDirectives(camelize(name));
        if (directiveConfig) {
          const [directive, styles] = directiveConfig;
          const aliasName = `__el_directive_${no}`;
          no += 1;
          addStyles(styles);
          directives.push([directive, aliasName]);
          return aliasName;
        }
        return full;
      });
      if (directives.length) {
        imports.add(genLibraryImport(directives));
      }
      if (imports.size) {
        s.prepend([...imports, ""].join("\n"));
      }
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: options.sourcemap ? s.generateMap({ source: id, includeContent: true }) : void 0
        };
      }
    }
  };
});

const module = defineNuxtModule({
  meta: {
    name: libraryName,
    configKey: "elementPlus"
  },
  defaults,
  setup(_options, nuxt) {
    const options = _options;
    resolveOptions();
    resolveThemes(options);
    nuxt.options.imports.autoImport !== false && resolveImports(options);
    nuxt.options.components !== false && resolveComponents(options);
    if (nuxt.options.ssr !== false) {
      addPluginTemplate(resolveInjection(options));
      addPluginTemplate(resolveTeleports(options));
    }
    nuxt.hook("vite:extendConfig", (config, { isClient }) => {
      const mode = isClient ? "client" : "server";
      config.plugins = config.plugins || [];
      config.plugins.push(transformPlugin.vite({
        include: options.include,
        exclude: options.exclude,
        sourcemap: nuxt.options.sourcemap[mode],
        transformStyles: (name) => resolveStyles(options, name),
        transformDirectives: (name) => resolveDirectives(options, name)
      }));
    });
    nuxt.hook("webpack:config", (configs) => {
      configs.forEach((config) => {
        const mode = config.name === "client" ? "client" : "server";
        config.plugins = config.plugins || [];
        config.plugins.push(transformPlugin.webpack({
          include: options.include,
          exclude: options.exclude,
          sourcemap: nuxt.options.sourcemap[mode],
          transformStyles: (name) => resolveStyles(options, name),
          transformDirectives: (name) => resolveDirectives(options, name)
        }));
      });
    });
  }
});

export { module as default };
